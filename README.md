# scenic-management-system
##景区管理系统

###1．建立主程序应用菜单选项
*描述*

主程序应用菜单选项包含：创建景区景点分布图，输出景区景点分布图，输出导游线路图，判断导游线路图有无回路，两个景点间的最短路径和最短距离，停车场车辆进出记录信息，输出道路修建规划图。
对选项采用数字标识进行选择，对其他错误输入可以进行判别，提示输入错误。
 
###2．导游线路图的创建
景点的信息包括景点的名称和近邻景点之间的通路和距离。用邻接链表存储景点分布图的信息，（带权无向）图的邻接链表。首要完成创建景区景点分布图和输出景区景点分布图（邻接矩阵）
建图子模块建立无向带权图，输入顶点信息和边的信息，输出邻接链表G。由于是无向边，输入一条边时构建两条边。定点信息至少包括：景点名称，景点简介，景点欢迎度，有无休息区，有无公厕。边的信息可以包括两个景点的距离和需要的时间。
输出图子模块：从邻接链表g转换成邻接矩阵a，并输出邻接矩阵a。图中边的权值∞用32767表示。

遍历结点序列与导游线路图转换的策略：
　　设遍历结果为v1→v2→…→vi→vi+1→…→vn
　　对于结点vi和vi+1，如果vi和vi+1存在边，则直接转换。
　　否则，加入边vi→vi-1，如果vi-1和vi+1存在边，则加入边vi-1→vi+1。
　　再否则，加入边vi-1→vi-2，如果vi-2和vi+1存在边，则加入边vi-2→vi+1。
　　如果vi-2和vi+1还不存在边，继续回溯，一定能找到某个整数k（因为景点分布图是连通图），使得vi-k和vi+1存在边，则加入边vi-k→vi+1。在本任务中，转换后的线路图存于数组vex1中。

数据的结构体
typedef struct ArcNode
{
}ArcNode;//定义顶点信息
typedef struct VNode
{
}VNode,AdjList[MAX_VERTEX_NUM];//定义边信息

typedef struct
{
}ALGraph;//定义邻接表
功能函数：
void CreatGraph(ALGraph &G);//创建图的邻接表存储
void OutputGraph(ALGraph G);//输出图的邻接表
对于图的数据信息建立，可以进行多组数据的测试，以保证该函数的功能正确，例如：

要求按如下图和权值来进行数据分析
景点——景点——距离权值

北门——狮子山——9
北门——仙云石——8
狮子山——一线天——7
狮子山——飞流瀑——6
仙云石——仙武湖——4
仙云石——九曲桥——5
仙武湖——九曲桥——7
一线天——观云台——11
飞流瀑——观云台——3
一线天——花卉园——10
观云台——红叶亭——15
花卉园——红叶亭——9
观云台——碧水亭——16
仙武湖——碧水亭——20
朝日峰——碧水潭——17
朝日峰——红叶亭——10
九曲桥——朝日峰——20


2．输出导游线路图及其图中的回路部分
景区旅游信息管理系统中制订旅游景点导游线路策略，首先通过遍历景点，给出一个入口景点，建立一个导游线路图，导游线路图用有向图表示。遍历采用深度优先策略，这也比较符合游客心理。
功能函数
输出导游线路图，由CreatTourSortGraph(G,G1)函数实现；
　  判断导游线路图有无回路，由TopoSort(G1)函数实现；
建立路线图
图的深度遍历函数：void DFSTraverse(ALGraph G);
判断要查的这两个顶点之间是否有直接相连的边：
bool IsEdge(ALGraph G,string v1,string v2); 
寻找要查找顶点位置：int LocateVex(ALGraph G,string v); 
例如：
 
回路（选做）
为了使导游线路图能够优化，可通过拓扑排序判断图中有无回路，若有回路，则打印输出回路中的景点，供人工优化。
计算每个顶点的入度，存储在indegree数组中将入度减为的顶点入栈，实现函数：
void FindInDegree(ALGraph G1,int indegree[]);
例如：
 
3．输出两个景点之间最短路径和最短距离
求两个景点间的最短路径和最短距离，由MiniDistanse(G1,path,D)函数实现；
　  输出道路修建规划图，在程序中由MiniSpanTree(G,G.adjlist[0].name)函数实现。
在导游线路图中，还为一些不愿按线路走的游客提供信息服务，比如从一个景点到另一个景点的最短路径和最短距离。在本线路图中将输出任意景点间的最短路径和最短距离。算法采用迪杰斯特拉算法（必做），弗洛伊德算法（选做）。
计算最短路径：void ShortestPath(ALGraph G,int path[][MAX_VERTEX_NUM],
double D[][MAX_VERTEX_NUM]); 
求最短路径：void OutPutShortestPath(ALGraph G,int path[][MAX_VERTEX_NUM],
double D[][MAX_VERTEX_NUM],int i,int j); 
例如：
 




4．输出道路修建规划图（选做）
在景区建设中，道路建设是其中一个重要内容。道路建设首先要保证能连通所有景点，但又要花最小的代价，可以通过求最小生成树来解决这个问题。本任务中假设修建道路的代价只与它的里程相关。
最小生成树函数：void MiniSpanTree(ALGraph G,string u)；
实现流程：使用循环初始化各个边的信息，初始化u已经在最小生成树中可以创建一个函数，将顶点加入生成树中，当新加入的顶点使距离更小了，就更改他。
例如
 
5、查找及排序
	查找功能
可以根据用户输入的关键字进行景点的查找，关键字可以在景点名称也可以在景点介绍中。查找成功则返回景点的相关简介，如果查找不成功请给予正确提示。
	排序功能
可以根据不同的需求进行排序，如按景点欢迎度（必做）或者景点的岔路数对景点进行排序，排序算法可以采用冒泡、快速、插入排序等。
排序后可以直接打印到控制台，检验排序或者查询后的数据数据是否完整。
6．输出车辆的进出信息
设停车场是一个可以停放n辆汽车的南北方向的狭长通道，且只有一个大门可供汽车进出。汽车在停车场内按车辆到达时间的先后顺序，依次由北向南排列（大门在最南端，最先到达的第一辆车停放在车场的最北端），若车场内已停满n辆车，那么后来的车只能在门外的便道上等候，一旦有车开走，则排在便道上的第一辆车即可开入；当停车场内某辆车要离开时，在它之后进入的车辆必须先退出车场为它让路，待该辆车开出大门外，其它车辆再按原次序进入车场，每辆停放在车场的车在它离开停车场时必须按它停留的时间长短交纳费用。试为停车场编制按上述要求进行管理的模拟程序。要求程序输出每辆车到达后的停车位置（停车场或便道上），以及某辆车离开停车场时应缴纳的费用和它在停车场内停留的时间。
设计思路
停车场的管理流程如下：
①	当车辆要进入停车场时，检查停车场是否已满，如果未满则车辆进入停车场；如果停车场已满，则车辆进入便道等候。
②	当车辆要求出栈时，先让在它之后进入停车场的车辆退出停车场为它让路，再让该车退出停车场，让路的所有车辆再按其原来进入停车场的次序进入停车场。之后，再检查在便道上是否有车等候，有车则让最先等待的那辆车进入停车场。
数据结构
由于停车场只有一个大门，当停车场内某辆车要离开时，在它之后进入的车辆必须先退出车场为它让路，先进停车场的后退出，后进车场的先退出，符合栈的“后进先出，先进后出”的操作特点，因此，可以用一个栈来模拟停车场。而当停车场满后，继续来到的其它车辆只能停在便道上，根据便道停车的特点，先排队的车辆先离开便道进入停车场，符合队列的“先进先出，后进后出”的操作特点，因此，可以用一个队列来模拟便道。排在停车场中间的车辆可以提出离开停车场，并且停车场内在要离开的车辆之后到达的车辆都必须先离开停车场为它让路，然后这些车辆依原来到达停车场的次序进入停车场，因此在前面已设的一个栈和一个队列的基础上，还需要有一个地方保存为了让路离开停车场的车辆，由于先退出停车场的后进入停车场，所以很显然保存让路车辆的场地也应该用一个栈来模拟。因此，本题求解过程中需用到两个栈和一个队列。栈以顺序结构实现，队列以链表结构实现。
车辆出入清单
程序提示：以栈模拟停车场，以队列模拟车场外的便道，按照从终端读入的输入数据序列进行模拟管理。每一组输入数据包括三个数据项：汽车“到达”或“离去”信息、汽车牌照号码以及到达或离去的时刻。对每一组输入数据进行操作后的输出信息为：若是车辆到达，则输出汽车在停车场内或便道上的停车位置；若是车辆离去，则输出汽车在停车场内停留的时间和应交纳的费用（在便道上停留的时间不收费）。
数据结构：
模拟停车场的堆栈的性质；
typedef struct zanlind{     
      int number;   //汽车车号
      int ar_time;   //汽车到达时间
}zanInode;
typedef struct{
   	zanInode   *base;   //停车场的堆栈底
     zanInode   *top;   //停车场的堆栈顶
     int stacksize_curren;
}stackhead;
